#+TITLE: Vialer Webphone SIPLib


* Goals

Hide the complexities of SIP, SDP and WebRTC from the implementation
of the Webphone through an easy to use modern Javascript API.

Uses =Promises= and =async= where possible, use events only where
neccessary (not in request/response flows).

** SIPLib has clear error handling.
** TODO .. does not keep state (which calls are open atm)?


* Use cases

- Register phone
- Unregister phone
- Accepting an incoming call
- Denying an incoming call
- Creating an outgoing call
- Hanging up a call (in or out)
- Putting a call on hold
- Putting a call out of hold
- Blind transfering a call
- Attended transfer of call
- Getting presence updates for contacts (blf)
- Enter DTMF keys in a call
- Muting a call?
- Switching audio devices during a call?

* Accidental complexity

- Websocket connection to the SIP proxy.
  - Connecting/disconnecting
  - Handling failures

- Setting up the WebRTC channels (SIP.js) does this.
- Requesting the audio/video devices to be used (SIP.js)
  - Is done by the SessionDescriptionHandler, maybe the audio stream
    handling could be decoupled from the SDH. Right now the SDH always
    does a =getUserMedia= call to get /a/ microphone.
- Negotiating the SDP (SIP.js).

- Logging..
  - Logging all SIP traffic?

* SIPlib client setup

- Which audio/video devices to use?
  - /how to switch/ a/v during a call? Is this possible?
- ice servers (stun)
- transport options (reconnection etc.?)
- user agent
- noanswertimeout?
- etc.

Maybe best to first just pass through the =options= to the =SIP.UA=
constructor?

* Example flows

#+begin_src js
  const client = new SipLibClient({
    proxy: 'websocket.voipgrid.nl',
    username: 'jos@vialerapp.com',
    password: 'xxxx',
    userMediaFlags
  });

  await client.register();

  // incoming call below
  sessions = {};
  client.on('invite', (session) => {
    // If DND, session.reject()
    sessions[session.id] = session;
    // reinvite..
    try {
      ringer();
      spawnNotification(session).then(action => session.accept());

      let accepted = await session.accepted();
      if (!accepted) {
        return;
      }

      showCallScreen();

      await session.active();
    } catch (e) {
      showErrorMessage(e)
    } finally {
      closeCallScreen();

      delete sessions[session.id];
    }
  });


  const session = client.call({number: '123', name: 'Alice'});
  sessions[session.id] = session;

  try {
    showOutgoingCallInProgress()

    let isAccepted = await session.accepted()
    if (!isAccepted) {
      showRejectedScreen();
      return;
    }

    showCallScreen();
    await session.terminated();
  } catch (e) {

  } finally {
    closeCallScreen();

    delete sessions[session.id];
  }


  if (await session.active()) { // wait until the call is picked up)
    await session.dtmf('#123');
    await session.hold();
    const other = client.call({number: '456', name: 'Bob'});
    if (await other.active()) {
    }
    await session.transfer(other);
  }
#+end_src
